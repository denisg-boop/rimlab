<!-- TCF ALL-IN-ONE v1 (UI + Filter) -->

<!-- ===== MOBILE UI ===== -->
<style>
  .tcfm-root, .tcfm-root *{ box-sizing:border-box; }
  .tcfm-root{
    width:100%;
    font-family: Yfont, Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    letter-spacing:-0.05em;
    color:#1A1A1A;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }
  #tcf-mobile{ display:none; }
  @media (max-width:767px){
    #tcf-mobile{ display:block; }
    #tcf-desktop{ display:none; }
  }
  .tcfm-wrap{ width:100%; padding:0 20px; }
  .tcfm-card{
    width:100%; max-width:393px; margin:24px auto;
    background:#F3F4F6; border-radius:15px; padding:26px 18px 22px;
  }
  .tcfm-label{ display:block; margin:10px 0 6px; font-size:18px; font-weight:400; padding-left:10px; }
  .tcfm-field{ position:relative; }
  .tcfm-select{
    width:100%; height:45px; border:none; outline:none; border-radius:15px;
    background:#FEFEFE; padding:0 44px 0 48px; font-size:18px; font-weight:500; color:#1A1A1A;
    appearance:none; -webkit-appearance:none;
    background-image:url('data:image/svg+xml;utf8,<svg width="24" height="24" xmlns="http://www.w3.org/2000/svg"><path d="M6 9l6 6 6-6" stroke="%23757575" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>');
    background-repeat:no-repeat; background-position:right 14px center; background-size:24px 24px;
  }
  .tcfm-select:invalid{ color:#A0A0A0; font-weight:400; }
  .tcfm-icon{
    position:absolute; left:14px; top:50%; transform:translateY(-50%);
    width:22px; height:22px; border-radius:6px; overflow:hidden; display:none; pointer-events:none;
  }
  .tcfm-icon img{ width:100%; height:100%; object-fit:contain; }
  .tcfm-btn{
    width:100%; height:45px; margin-top:16px; border:none; border-radius:15px;
    background:#1A1A1A; color:#FEFEFE; font-size:18px; font-weight:500; cursor:pointer; transition:all .25s ease;
  }
  .tcfm-btn:hover{ background:#F18042; color:#1A1A1A; }
  @media (max-width:767px){
    .tcfm-card{ max-width:100%; margin:20px 0; }
  }
</style>

<div class="tcfm-root" id="tcf-mobile">
  <div class="tcfm-wrap">
    <div class="tcfm-card">
      <label class="tcfm-label" for="tcfm-brand">Марка авто</label>
      <div class="tcfm-field">
        <span class="tcfm-icon" id="tcfm-brandIcon"><img id="tcfm-brandIconImg" alt=""></span>
        <select class="tcfm-select" id="tcfm-brand" required>
          <option value="" disabled selected>Выберите марку</option>
        </select>
      </div>

      <label class="tcfm-label" for="tcfm-series">Серия</label>
      <div class="tcfm-field">
        <select class="tcfm-select" id="tcfm-series" required>
          <option value="" disabled selected>Выберите серию</option>
        </select>
      </div>

      <label class="tcfm-label" for="tcfm-body">Кузов</label>
      <div class="tcfm-field">
        <select class="tcfm-select" id="tcfm-body" required>
          <option value="" disabled selected>Выберите кузов</option>
        </select>
      </div>

      <button class="tcfm-btn" type="button" id="tcfm-apply">Подобрать</button>
    </div>
  </div>
</div>

<!-- ===== DESKTOP UI ===== -->
<style>
  .tcfd-root, .tcfd-root *{ box-sizing:border-box; }
  .tcfd-root{
    font-family: Yfont, Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    letter-spacing:-0.05em;
    color:#1A1A1A;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }
  .tcfd-bg{
    position:relative; width:100%; max-width:1365px; height:300px; margin:0 auto;
    background:#F3F4F6; border-radius:30px; overflow:hidden;
  }
  .tcfd-label{
    position:absolute; height:26px; display:flex; align-items:center; justify-content:flex-start;
    font-size:24px; font-weight:400;
  }
  .tcfd-field{
    position:absolute; width:330px; height:60px; background:#FEFEFE; border-radius:25px; overflow:visible;
  }
  .tcfd-select{
    appearance:none; -webkit-appearance:none; width:100%; height:100%;
    border:none; outline:none; background:#FEFEFE; border-radius:25px;
    padding:0 52px 0 52px; font-size:20px; font-weight:500; letter-spacing:inherit; color:#1A1A1A;
  }
  .tcfd-select:invalid{ color:#A0A0A0; font-weight:400; }
  .tcfd-icon{
    position:absolute; left:14px; top:50%; transform:translateY(-50%);
    width:25px; height:25px; border-radius:8px; overflow:hidden; display:none; pointer-events:none; z-index:2;
  }
  .tcfd-icon img{ width:100%; height:100%; object-fit:contain; }
  .tcfd-arrow{
    position:absolute; width:35px; height:35px; display:flex; align-items:center; justify-content:center;
    pointer-events:none; z-index:3;
  }
  .tcfd-btn{
    position:absolute; width:330px; height:60px; border:none; outline:none; background:#1A1A1A;
    border-radius:25px; color:#FEFEFE; font-size:24px; font-weight:400; cursor:pointer; transition:all .25s ease; z-index:3;
  }
  .tcfd-btn:hover{ background:#F18042; color:#1A1A1A; }
  .tcfd-car{
    position:absolute; right:0; top:50%; transform:translateY(-50%);
    width:440px; max-width:50%; height:auto; object-fit:contain; pointer-events:none; z-index:1;
  }
  @media (max-width: 1000px){
    .tcfd-car{ right:-20px; z-index:0; }
    .tcfd-field, .tcfd-label, .tcfd-btn, .tcfd-arrow{ z-index:2; }
  }
</style>

<div class="tcfd-root" id="tcf-desktop" style="padding:20px 0;">
  <div class="tcfd-bg">
    <div class="tcfd-label" style="left:69px; top:48px; width:240px;">Марка авто</div>
    <div class="tcfd-label" style="left:429px; top:48px; width:240px;">Серия</div>
    <div class="tcfd-label" style="left:69px; top:160px; width:240px;">Кузов</div>

    <div class="tcfd-field" style="left:51px; top:79px;">
      <span class="tcfd-icon" id="tcfd-brandIcon"><img id="tcfd-brandIconImg" alt=""></span>
      <select class="tcfd-select" id="tcfd-brand" required>
        <option value="" disabled selected>Выберите марку</option>
      </select>
    </div>

    <div class="tcfd-field" style="left:411px; top:79px;">
      <select class="tcfd-select" id="tcfd-series" required>
        <option value="" disabled selected>Выберите серию</option>
      </select>
    </div>

    <div class="tcfd-field" style="left:51px; top:191px;">
      <select class="tcfd-select" id="tcfd-body" required>
        <option value="" disabled selected>Выберите кузов</option>
      </select>
    </div>

    <button class="tcfd-btn" type="button" id="tcfd-apply" style="left:411px; top:191px;">Подобрать</button>

    <div class="tcfd-arrow" style="left:325px; top:93px;">
      <svg width="35" height="35" viewBox="0 0 35 35" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M8.75 13.125L17.5 21.875L26.25 13.125" stroke="#757575" stroke-width="2.91667" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </div>
    <div class="tcfd-arrow" style="left:684px; top:93px;">
      <svg width="35" height="35" viewBox="0 0 35 35" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M8.75 13.125L17.5 21.875L26.25 13.125" stroke="#757575" stroke-width="2.91667" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </div>
    <div class="tcfd-arrow" style="left:328px; top:204px;">
      <svg width="35" height="35" viewBox="0 0 35 35" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M8.75 13.125L17.5 21.875L26.25 13.125" stroke="#757575" stroke-width="2.91667" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </div>

    <img class="tcfd-car"
      src="https://static.tildacdn.com/tild3163-3630-4263-b564-323135356535/amg.png"
      alt="Автомобиль" loading="lazy" decoding="async">
  </div>
</div>

<!-- ===== FILTER + LOADER ===== -->
<style>
  #tcf-noresults {
    display:none; margin:16px 0; padding:12px 16px; border-radius:10px;
    background:#fff5f5; color:#b40000; font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  }
  .tcf-card-hidden{ display:none !important; }
</style>

<div id="tcf-noresults">Нет подходящих дисков</div>

<script>
(function(){
  "use strict";

  /*
   ======================================================================
   НАСТРОЙКИ (можно безопасно менять)
   ======================================================================
   1) Вставьте ваш рабочий URL Google Sheets (pubhtml или сразу CSV).
   2) Если не находит карточки — правьте STORE.SELECTORS.
   3) Если UID не извлекается — правьте CARD.LINK_SELECTOR и UID_REGEX.
   4) Если не заполняются списки — проверьте имена колонок CSV в SHEET.COLUMNS.
   5) Если появляются "дырки" — это решено через отдельный контейнер результатов,
      где карточки показываются клонами плотной сеткой (исходная сетка скрывается).
  */
  var CFG = {
    SHEET: {
      SHEET_PUBHTML_URL: "https://docs.google.com/spreadsheets/d/e/2PACX-1vSD_RlVif74yW6a16kwBb4OSqt4OLXPPIjehIxIFqRC9PvmKfTejpn61LOttkiT86Iv3A0bORAxrvwm/pubhtml?gid=693646388&single=true",
      CSV_URL: "",
      GID: "693646388",
      SHEET_ID: "", // можно оставить пустым: тогда возьмём из SHEET_PUBHTML_URL
      COLUMNS: {
        UID: "Tilda UID",
        BRAND: "Brand",
        COMPAT: "Characteristics:Совместимость",
        TITLE: "Title"
      }
    },
    STORE: {
      ROOT_SELECTOR: ".js-store,.t-store,.t-store__container,.uc-store",
      GRID_SELECTOR: ".js-store-grid-cont, .t-store__grid-cont, .t-store__grid, .js-store-grid",
      CARD_SELECTOR: ".js-product, .t-store__card, .js-store-prod, .t-card, .t-store__product",
      SHOW_MORE_SELECTOR: ".t-store__show-more, .js-store-partsload-more, .t-store__load-more-btn, button[data-show-more]"
    },
    CARD: {
      LINK_SELECTOR: "a[href*='/tproduct/']",
      TITLE_SELECTOR: ".t-store__card__title, .t-name, .js-store-prod-name, .t-card__title",
      UID_REGEX: /\/tproduct\/[\w\-]+-(\d+)/i
    },
    FILTER: {
      BODY_EMPTY_LABEL: "—",
      NO_RESULTS_TEXT: "Нет подходящих дисков",
      STORAGE_KEY_SELECTION: "tcf_selection_v2",
      STORAGE_KEY_CACHE: "tcf_sheet_cache_v2"
    },
    CACHE: {
      ENABLE_LOCALSTORAGE: true,
      TTL_MS: 2 * 60 * 1000,
      FORCE_REFRESH: true
    },
    DBG: false
  };

  function log(){ if(!CFG.DBG || !window.console || !console.log) return; console.log.apply(console, ["[TCF]"] .concat(Array.prototype.slice.call(arguments))); }
  function norm(v){ return (v == null ? "" : String(v)).replace(/ /g, " ").replace(/\s+/g, " ").trim(); }
  function up(v){ return norm(v).toUpperCase(); }
  function safeKey(v){ return up(v).replace(/[^A-Z0-9А-ЯЁ]+/g, " ").replace(/\s+/g, " ").trim(); }

  var STATE = {
    data: null,
    activeFilter: null,
    observer: null,
    debounceTimer: 0
  };

  function firstBySelectors(selectorList, root){
    var base = root || document;
    var arr = selectorList.split(",");
    for(var i=0;i<arr.length;i++){
      var sel = norm(arr[i]);
      if(!sel) continue;
      var el = base.querySelector(sel);
      if(el) return el;
    }
    return null;
  }

  function csvUrlFromSettings(){
    if(norm(CFG.SHEET.CSV_URL)) return CFG.SHEET.CSV_URL;
    var raw = norm(CFG.SHEET.SHEET_PUBHTML_URL);
    if(!raw) return "";
    try{
      var u = new URL(raw);
      var gid = norm(CFG.SHEET.GID).replace("gid=", "") || u.searchParams.get("gid") || "";
      u.pathname = u.pathname.replace(/\/pubhtml$/i, "/pub");
      u.search = "";
      u.searchParams.set("output", "csv");
      if(gid) u.searchParams.set("gid", gid);
      return u.toString();
    }catch(e){ return raw; }
  }

  /*
    Надежный CSV-парсер без внешних библиотек.
    Поддержка:
    - запятые в кавычках
    - переносы строк в кавычках
    - экранирование двойной кавычки "" внутри поля
  */
  function parseCsv(text){
    var rows = [];
    var row = [];
    var cur = "";
    var inQuotes = false;
    for(var i=0;i<text.length;i++){
      var ch = text.charAt(i);
      var next = text.charAt(i+1);
      if(ch === '"'){
        if(inQuotes && next === '"'){ cur += '"'; i++; }
        else { inQuotes = !inQuotes; }
      }else if(ch === ',' && !inQuotes){
        row.push(cur); cur = "";
      }else if((ch === "\n" || ch === "\r") && !inQuotes){
        if(ch === "\r" && next === "\n") i++;
        row.push(cur); rows.push(row);
        row = []; cur = "";
      }else{
        cur += ch;
      }
    }
    if(cur.length || row.length){ row.push(cur); rows.push(row); }
    return rows;
  }

  function findColumnIndex(headers, expected){
    var target = up(expected);
    var i;
    for(i=0;i<headers.length;i++) if(up(headers[i]) === target) return i;
    for(i=0;i<headers.length;i++) if(up(headers[i]).indexOf(target) !== -1) return i;
    return -1;
  }

  /*
    Разбор сегмента "Серия КУЗОВ".
    Пример: "X5 G05" => series="X5", body="G05".
    Если кузов в сегменте отсутствует, body = BODY_EMPTY_LABEL.
  */
  function splitSeriesAndBody(segment){
    var clean = norm(segment);
    if(!clean) return null;
    var parts = clean.split(" ");
    if(parts.length === 1){
      return { series: up(parts[0]), body: CFG.FILTER.BODY_EMPTY_LABEL };
    }
    var last = up(parts[parts.length - 1]);
    var bodyLike = /(^[A-ZА-Я]{1,4}\d{1,4}$)|(^\d{2,4}$)|(^[A-ZА-Я]\d[A-ZА-Я0-9]*$)/i.test(last);
    if(bodyLike){
      return { series: up(parts.slice(0, parts.length - 1).join(" ")), body: last };
    }
    return { series: up(clean), body: CFG.FILTER.BODY_EMPTY_LABEL };
  }

  function parseCompat(rawCompat){
    var raw = norm(rawCompat);
    if(!raw) return [];
    var segments = raw.split(";");
    var out = [];
    for(var i=0;i<segments.length;i++){
      var item = splitSeriesAndBody(segments[i]);
      if(item && item.series){ out.push(item); }
    }
    return out;
  }

  function buildDataIndex(rows){
    var headers = rows[0] || [];
    var idxBrand = findColumnIndex(headers, CFG.SHEET.COLUMNS.BRAND);
    var idxCompat = findColumnIndex(headers, CFG.SHEET.COLUMNS.COMPAT);
    var idxUid = findColumnIndex(headers, CFG.SHEET.COLUMNS.UID);
    var idxTitle = findColumnIndex(headers, CFG.SHEET.COLUMNS.TITLE);
    if(idxBrand < 0 || idxCompat < 0){ throw new Error("В CSV не найдены обязательные колонки Brand / Compatibility"); }

    var tree = {};
    var mapping = {};

    for(var r=1;r<rows.length;r++){
      var row = rows[r] || [];
      var brand = up(row[idxBrand]);
      var compat = norm(row[idxCompat]);
      var uid = idxUid >= 0 ? norm(row[idxUid]) : "";
      var title = idxTitle >= 0 ? norm(row[idxTitle]) : "";
      if(!brand || !compat) continue;

      var pairs = parseCompat(compat);
      if(!pairs.length) continue;

      if(!tree[brand]) tree[brand] = {};
      if(!mapping[brand]) mapping[brand] = {};

      for(var p=0;p<pairs.length;p++){
        var series = pairs[p].series;
        var body = pairs[p].body || CFG.FILTER.BODY_EMPTY_LABEL;

        if(!tree[brand][series]) tree[brand][series] = [];
        if(tree[brand][series].indexOf(body) === -1) tree[brand][series].push(body);

        if(!mapping[brand][series]) mapping[brand][series] = {};
        if(!mapping[brand][series][body]) mapping[brand][series][body] = [];
        mapping[brand][series][body].push({ uid: uid, title: title, titleKey: safeKey(title) });
      }
    }

    var brands = Object.keys(tree).sort();
    for(var b=0;b<brands.length;b++){
      var ser = Object.keys(tree[brands[b]]).sort();
      for(var s=0;s<ser.length;s++) tree[brands[b]][ser[s]].sort();
    }

    return { tree: tree, mapping: mapping, brands: brands };
  }

  function loadCache(){
    if(!CFG.CACHE.ENABLE_LOCALSTORAGE || CFG.CACHE.FORCE_REFRESH) return null;
    try{
      var raw = localStorage.getItem(CFG.FILTER.STORAGE_KEY_CACHE);
      if(!raw) return null;
      var obj = JSON.parse(raw);
      if(!obj || !obj.ts || !obj.data) return null;
      if(Date.now() - obj.ts > CFG.CACHE.TTL_MS) return null;
      return obj.data;
    }catch(e){ return null; }
  }
  function saveCache(data){
    if(!CFG.CACHE.ENABLE_LOCALSTORAGE) return;
    try{ localStorage.setItem(CFG.FILTER.STORAGE_KEY_CACHE, JSON.stringify({ ts: Date.now(), data: data })); }catch(e){}
  }

  // Фолбэк: читаем кэш даже если TTL истёк (на случай временного сбоя сети/Google).
  function loadStaleCache(){
    if(!CFG.CACHE.ENABLE_LOCALSTORAGE) return null;
    try{
      var raw = localStorage.getItem(CFG.FILTER.STORAGE_KEY_CACHE);
      if(!raw) return null;
      var obj = JSON.parse(raw);
      return (obj && obj.data) ? obj.data : null;
    }catch(e){ return null; }
  }



  function readAny(obj, keys){
    if(!obj) return "";
    for(var i=0;i<keys.length;i++){
      var k = keys[i];
      if(obj[k] != null && String(obj[k]).length) return String(obj[k]);
    }
    return "";
  }

  function extractCompatFromObj(prod){
    var direct = readAny(prod, [
      "Characteristics:Совместимость", "characteristics:совместимость", "Совместимость", "compatibility", "Compatibility", "compat"
    ]);
    if(direct) return direct;

    var chars = prod.characteristics || prod.Characteristics || prod.features || prod.params || null;
    if(chars && typeof chars === "object"){
      if(Object.prototype.toString.call(chars) === "[object Array]"){
        for(var i=0;i<chars.length;i++){
          var row = chars[i] || {};
          var n = up(readAny(row, ["name","title","key","label"]));
          var v = readAny(row, ["value","val","text"]);
          if(n.indexOf("СОВМЕСТИМОСТ") !== -1 || n.indexOf("COMPAT") !== -1) return v;
        }
      }else{
        var val = readAny(chars, ["Совместимость", "совместимость", "Compatibility", "compatibility"]);
        if(val) return val;
      }
    }
    return "";
  }

  function productToRow(prod){
    var uid = readAny(prod, ["uid","tilda_uid","Tilda UID","id","productUid","productuid"]);
    var title = readAny(prod, ["title","name","Title"]);
    var brand = readAny(prod, ["Brand","brand","Марка","mark"]);
    var compat = extractCompatFromObj(prod);
    if(!brand || !compat) return null;
    return { uid: uid, title: title, brand: brand, compat: compat };
  }

  // Радикально другой источник: берём данные прямо из уже загруженного каталога Tilda (без Google fetch).
  function collectTildaProducts(){
    var buckets = [];
    var w = window;
    var candidates = [
      w.t_store, w.tcart, w.tildaStore, w.tildaCatalog, w.t_store_data, w.t_store_products,
      w.t_store__products, w.t754__store, w.t156__store, w.t_storeparts
    ];
    for(var i=0;i<candidates.length;i++) if(candidates[i]) buckets.push(candidates[i]);

    // Плюс проходим глобальные переменные — часто Tilda кладёт данные в project-scoped объекты.
    var keys = Object.keys(window);
    for(i=0;i<keys.length;i++){
      var k = keys[i];
      if(k.indexOf("_tilda") !== -1 || k.indexOf("store") !== -1 || k.indexOf("catalog") !== -1 || k.indexOf("product") !== -1){
        try{ if(window[k]) buckets.push(window[k]); }catch(e){}
      }
    }

    var rows = [];
    var seen = {};

    function pushProd(obj){
      var row = productToRow(obj);
      if(!row) return;
      var sig = up(row.brand) + "|" + up(row.compat) + "|" + row.uid + "|" + safeKey(row.title);
      if(seen[sig]) return;
      seen[sig] = true;
      rows.push(row);
    }

    function walk(node, depth){
      if(!node || depth > 3) return;
      var t = Object.prototype.toString.call(node);
      if(t === "[object Array]"){
        for(var a=0;a<node.length;a++){
          var it = node[a];
          if(it && typeof it === "object"){
            pushProd(it);
            walk(it, depth + 1);
          }
        }
        return;
      }
      if(typeof node === "object"){
        pushProd(node);
        var ks = Object.keys(node);
        for(var j=0;j<ks.length;j++){
          var val;
          try{ val = node[ks[j]]; }catch(e){ continue; }
          if(val && typeof val === "object") walk(val, depth + 1);
        }
      }
    }

    for(i=0;i<buckets.length;i++) walk(buckets[i], 0);
    return rows;
  }

  function buildDataFromRuntimeRows(rows){
    var tree = {};
    var mapping = {};
    for(var i=0;i<rows.length;i++){
      var brand = up(rows[i].brand);
      var compat = norm(rows[i].compat);
      var uid = norm(rows[i].uid);
      var title = norm(rows[i].title);
      var pairs = parseCompat(compat);
      if(!brand || !pairs.length) continue;

      if(!tree[brand]) tree[brand] = {};
      if(!mapping[brand]) mapping[brand] = {};

      for(var p=0;p<pairs.length;p++){
        var series = pairs[p].series;
        var body = pairs[p].body || CFG.FILTER.BODY_EMPTY_LABEL;
        if(!tree[brand][series]) tree[brand][series] = [];
        if(tree[brand][series].indexOf(body) === -1) tree[brand][series].push(body);

        if(!mapping[brand][series]) mapping[brand][series] = {};
        if(!mapping[brand][series][body]) mapping[brand][series][body] = [];
        mapping[brand][series][body].push({ uid: uid, title: title, titleKey: safeKey(title) });
      }
    }

    var brands = Object.keys(tree).sort();
    for(var b=0;b<brands.length;b++){
      var seriesArr = Object.keys(tree[brands[b]]).sort();
      for(var s=0;s<seriesArr.length;s++) tree[brands[b]][seriesArr[s]].sort();
    }
    return { tree: tree, mapping: mapping, brands: brands };
  }

  function loadFromTildaRuntime(){
    var rows = collectTildaProducts();
    if(!rows || !rows.length) return null;
    var data = buildDataFromRuntimeRows(rows);
    if(!data.brands || !data.brands.length) return null;
    log("runtime data loaded", data.brands.length, "brands");
    return data;
  }

  // Получаем spreadsheetId (нужен для JSONP-фолбэка gviz).
  function getSheetId(){
    var explicit = norm(CFG.SHEET.SHEET_ID);
    if(explicit) return explicit;
    var raw = norm(CFG.SHEET.SHEET_PUBHTML_URL);
    if(!raw) return "";
    var m = raw.match(/\/spreadsheets\/d\/e\/([^\/\?]+)/i); // новый формат /d/e/<id>
    if(m && m[1]) return m[1];
    m = raw.match(/\/spreadsheets\/d\/([^\/\?]+)/i); // старый формат /d/<id>
    return (m && m[1]) ? m[1] : "";
  }

  function gvizJsonpUrl(){
    var sid = getSheetId();
    var gid = norm(CFG.SHEET.GID).replace("gid=", "");
    if(!sid || !gid) return "";
    // tqx=responseHandler:<fn>;out:json => ответ выполняется как JS, минуя CORS fetch.
    return "https://docs.google.com/spreadsheets/d/e/" + encodeURIComponent(sid) + "/gviz/tq?gid=" + encodeURIComponent(gid) + "&headers=1&tqx=responseHandler:__TCF_GVIZ_CB;out:json";
  }

  function rowsFromGvizResponse(resp){
    var table = resp && resp.table ? resp.table : null;
    if(!table || !table.cols || !table.rows) throw new Error("GVIZ: некорректный ответ");

    var rows = [];
    var headers = [];
    var i, j;
    for(i=0;i<table.cols.length;i++){
      var col = table.cols[i] || {};
      headers.push(norm(col.label || col.id || ("col" + i)));
    }
    rows.push(headers);

    for(i=0;i<table.rows.length;i++){
      var r = table.rows[i] || {};
      var cells = r.c || [];
      var outRow = [];
      for(j=0;j<headers.length;j++){
        var cell = cells[j];
        var val = "";
        if(cell){
          if(cell.f != null && String(cell.f).length) val = String(cell.f);
          else if(cell.v != null) val = String(cell.v);
        }
        outRow.push(val);
      }
      rows.push(outRow);
    }
    return rows;
  }

  function fetchViaGvizJsonp(){
    return new Promise(function(resolve, reject){
      var url = gvizJsonpUrl();
      if(!url) return reject(new Error("GVIZ URL пустой"));

      var cbName = "__TCF_GVIZ_CB";
      var timeoutId = 0;
      var script = document.createElement("script");

      function cleanup(){
        if(timeoutId) window.clearTimeout(timeoutId);
        try{ delete window[cbName]; }catch(e){ window[cbName] = null; }
        if(script && script.parentNode) script.parentNode.removeChild(script);
      }

      window[cbName] = function(resp){
        try{
          var rows = rowsFromGvizResponse(resp);
          cleanup();
          resolve(rows);
        }catch(e){
          cleanup();
          reject(e);
        }
      };

      timeoutId = window.setTimeout(function(){ cleanup(); reject(new Error("GVIZ timeout")); }, 10000);
      script.src = url;
      script.async = true;
      script.onerror = function(){ cleanup(); reject(new Error("GVIZ script error")); };
      (document.head || document.body).appendChild(script);
    });
  }

  function fetchData(){
    if(STATE.data && !CFG.CACHE.FORCE_REFRESH) return Promise.resolve(STATE.data);
    var cached = loadCache();
    if(cached){ STATE.data = cached; return Promise.resolve(cached); }

    // 0) Новый приоритет: пробуем взять данные прямо из каталога Tilda (без сети).
    var runtimeData = loadFromTildaRuntime();
    if(runtimeData){ STATE.data = runtimeData; saveCache(runtimeData); return Promise.resolve(runtimeData); }

    var url = csvUrlFromSettings();
    if(!url || url.indexOf("[ВСТАВИТЬ") !== -1){
      return Promise.reject(new Error("Не задан рабочий URL таблицы в CFG.SHEET.SHEET_PUBHTML_URL или CFG.SHEET.CSV_URL"));
    }

    function finalize(rows){
      var data = buildDataIndex(rows);
      STATE.data = data;
      saveCache(data);
      return data;
    }

    // 1) fetch CSV.
    return fetch(url, { cache: "no-store" })
      .then(function(res){ if(!res.ok) throw new Error("Ошибка загрузки CSV: " + res.status); return res.text(); })
      .then(function(text){ return finalize(parseCsv(text)); })
      .catch(function(errFetch){
        // 2) gviz JSONP.
        return fetchViaGvizJsonp()
          .then(function(rows){ return finalize(rows); })
          .catch(function(errGviz){
            // 3) На случай поздней инициализации Tilda пробуем runtime ещё раз.
            var runtimeLate = loadFromTildaRuntime();
            if(runtimeLate){ STATE.data = runtimeLate; saveCache(runtimeLate); return runtimeLate; }
            // 4) Старый кэш.
            var stale = loadStaleCache();
            if(stale){ STATE.data = stale; return stale; }
            throw new Error("Не удалось загрузить таблицу: runtime/fetch/gviz/cache. fetch=" + errFetch.message + "; gviz=" + errGviz.message);
          });
      });
  }

  function optionFill(select, list, placeholder){
    if(!select) return;
    while(select.firstChild) select.removeChild(select.firstChild);
    var ph = document.createElement("option");
    ph.value = ""; ph.text = placeholder; ph.disabled = true; ph.selected = true;
    select.appendChild(ph);
    for(var i=0;i<list.length;i++){
      var op = document.createElement("option");
      op.value = list[i];
      op.text = list[i];
      select.appendChild(op);
    }
  }

  function getUI(){
    return {
      dBrand: document.getElementById("tcfd-brand"),
      dSeries: document.getElementById("tcfd-series"),
      dBody: document.getElementById("tcfd-body"),
      dApply: document.getElementById("tcfd-apply"),
      mBrand: document.getElementById("tcfm-brand"),
      mSeries: document.getElementById("tcfm-series"),
      mBody: document.getElementById("tcfm-body"),
      mApply: document.getElementById("tcfm-apply")
    };
  }

  function saveSelection(sel){
    try{ localStorage.setItem(CFG.FILTER.STORAGE_KEY_SELECTION, JSON.stringify(sel)); }catch(e){}
  }
  function readSelection(){
    try{ var raw = localStorage.getItem(CFG.FILTER.STORAGE_KEY_SELECTION); return raw ? JSON.parse(raw) : null; }catch(e){ return null; }
  }

  function syncPair(a, b, value){ if(a) a.value = value || ""; if(b) b.value = value || ""; }

  function updateSeriesOptions(data, brand){
    var ui = getUI();
    var list = data.tree[brand] ? Object.keys(data.tree[brand]).sort() : [];
    optionFill(ui.dSeries, list, "Выберите серию");
    optionFill(ui.mSeries, list, "Выберите серию");
    optionFill(ui.dBody, [], "Выберите кузов");
    optionFill(ui.mBody, [], "Выберите кузов");
  }

  function updateBodyOptions(data, brand, series){
    var ui = getUI();
    var list = (data.tree[brand] && data.tree[brand][series]) ? data.tree[brand][series] : [];
    optionFill(ui.dBody, list, "Выберите кузов");
    optionFill(ui.mBody, list, "Выберите кузов");
  }

  function getStoreParts(){
    var grid = firstBySelectors(CFG.STORE.GRID_SELECTOR);
    var root = firstBySelectors(CFG.STORE.ROOT_SELECTOR) || (grid ? grid.parentNode : null);
    var showMore = firstBySelectors(CFG.STORE.SHOW_MORE_SELECTOR, root || document);
    return { root: root, grid: grid, showMore: showMore };
  }

  function getCards(grid){
    if(!grid) return [];
    var list = grid.querySelectorAll(CFG.STORE.CARD_SELECTOR);
    return Array.prototype.slice.call(list || []);
  }

  function extractCardUid(card){
    var attrs = ["data-product-uid", "data-product-id", "data-uid", "data-product-gen-uid"];
    for(var i=0;i<attrs.length;i++){
      var v = norm(card.getAttribute(attrs[i]));
      if(v) return v;
    }
    var link = card.querySelector(CFG.CARD.LINK_SELECTOR);
    var href = link ? norm(link.getAttribute("href")) : "";
    if(!href) return "";
    var m = href.match(CFG.CARD.UID_REGEX);
    return m && m[1] ? m[1] : "";
  }

  function extractCardTitle(card){
    var t = card.querySelector(CFG.CARD.TITLE_SELECTOR);
    return t ? norm(t.textContent) : "";
  }

  function getOrCreateResultsContainer(parts){
    var id = "tcf-results-grid";
    var box = document.getElementById(id);
    if(!box){
      box = document.createElement("div");
      box.id = id;
      box.style.display = "none";
      box.style.width = "100%";
      box.style.flexWrap = "wrap";
      box.style.alignItems = "stretch";
      box.style.justifyContent = "flex-start";
      box.style.gap = "20px";
      box.style.marginTop = "0";
      box.style.boxSizing = "border-box";
      box.className = "tcf-results-grid";
      if(parts.grid && parts.grid.parentNode){
        parts.grid.parentNode.insertBefore(box, parts.grid.nextSibling);
      }
    }
    return box;
  }

  function setNoResultMessage(show){
    var msg = document.getElementById("tcf-noresults");
    if(!msg){
      msg = document.createElement("div");
      msg.id = "tcf-noresults";
      msg.innerHTML = CFG.FILTER.NO_RESULTS_TEXT;
      document.body.appendChild(msg);
    }
    msg.style.display = show ? "block" : "none";
  }

  function resetFilter(){
    STATE.activeFilter = null;
    var parts = getStoreParts();
    var resultGrid = document.getElementById("tcf-results-grid");
    if(resultGrid){
      resultGrid.style.display = "none";
      while(resultGrid.firstChild) resultGrid.removeChild(resultGrid.firstChild);
    }
    if(parts.grid) parts.grid.style.display = "";
    if(parts.showMore) parts.showMore.style.display = "";
    setNoResultMessage(false);
  }

  function buildAllowedIndex(matches){
    var out = { uid: {}, title: {} };
    for(var i=0;i<matches.length;i++){
      if(matches[i].uid) out.uid[matches[i].uid] = true;
      if(matches[i].titleKey) out.title[matches[i].titleKey] = true;
    }
    return out;
  }

  function cloneCard(card){
    var clone = card.cloneNode(true);
    clone.style.display = "";
    clone.className = card.className;
    return clone;
  }

  function applyFilterToDom(selection){
    if(!STATE.data) return;
    var brand = selection.brand;
    var series = selection.series;
    var body = selection.body;
    var matches = (((STATE.data.mapping[brand] || {})[series] || {})[body]) || [];
    var allow = buildAllowedIndex(matches);

    var parts = getStoreParts();
    if(!parts.grid) return;
    var cards = getCards(parts.grid);
    var resultGrid = getOrCreateResultsContainer(parts);
    while(resultGrid.firstChild) resultGrid.removeChild(resultGrid.firstChild);

    var visible = 0;
    for(var i=0;i<cards.length;i++){
      var uid = extractCardUid(cards[i]);
      var titleKey = safeKey(extractCardTitle(cards[i]));
      var ok = false;
      if(uid && allow.uid[uid]) ok = true;
      if(!ok && titleKey && allow.title[titleKey]) ok = true;
      if(ok){ resultGrid.appendChild(cloneCard(cards[i])); visible++; }
    }

    parts.grid.style.display = "none";
    if(parts.showMore) parts.showMore.style.display = "none";
    resultGrid.style.display = "flex";

    if(visible === 0){
      setNoResultMessage(true);
      resetFilter();
    }else{
      setNoResultMessage(false);
      try{ resultGrid.scrollIntoView({ behavior: "smooth", block: "start" }); }catch(e){}
    }
  }

  function applyFilter(){
    var ui = getUI();
    var brand = norm((ui.dBrand && ui.dBrand.value) || (ui.mBrand && ui.mBrand.value));
    var series = norm((ui.dSeries && ui.dSeries.value) || (ui.mSeries && ui.mSeries.value));
    var body = norm((ui.dBody && ui.dBody.value) || (ui.mBody && ui.mBody.value));
    if(!brand || !series || !body){ alert("Выберите марку, серию и кузов."); return; }

    var sel = { brand: brand, series: series, body: body };
    STATE.activeFilter = sel;
    saveSelection(sel);
    applyFilterToDom(sel);
  }

  function bindUi(data){
    var ui = getUI();
    optionFill(ui.dBrand, data.brands, "Выберите марку");
    optionFill(ui.mBrand, data.brands, "Выберите марку");
    optionFill(ui.dSeries, [], "Выберите серию");
    optionFill(ui.mSeries, [], "Выберите серию");
    optionFill(ui.dBody, [], "Выберите кузов");
    optionFill(ui.mBody, [], "Выберите кузов");

    function onBrandChanged(value){
      syncPair(ui.dBrand, ui.mBrand, value);
      updateSeriesOptions(data, value);
      saveSelection({ brand: value, series: "", body: "" });
      resetFilter();
    }

    function onSeriesChanged(value){
      var b = norm((ui.dBrand && ui.dBrand.value) || (ui.mBrand && ui.mBrand.value));
      syncPair(ui.dSeries, ui.mSeries, value);
      updateBodyOptions(data, b, value);
      saveSelection({ brand: b, series: value, body: "" });
      resetFilter();
    }

    function onBodyChanged(value){
      var b = norm((ui.dBrand && ui.dBrand.value) || (ui.mBrand && ui.mBrand.value));
      var s = norm((ui.dSeries && ui.dSeries.value) || (ui.mSeries && ui.mSeries.value));
      syncPair(ui.dBody, ui.mBody, value);
      saveSelection({ brand: b, series: s, body: value });
    }

    if(ui.dBrand) ui.dBrand.addEventListener("change", function(){ onBrandChanged(this.value); });
    if(ui.mBrand) ui.mBrand.addEventListener("change", function(){ onBrandChanged(this.value); });
    if(ui.dSeries) ui.dSeries.addEventListener("change", function(){ onSeriesChanged(this.value); });
    if(ui.mSeries) ui.mSeries.addEventListener("change", function(){ onSeriesChanged(this.value); });
    if(ui.dBody) ui.dBody.addEventListener("change", function(){ onBodyChanged(this.value); });
    if(ui.mBody) ui.mBody.addEventListener("change", function(){ onBodyChanged(this.value); });

    if(ui.dApply) ui.dApply.addEventListener("click", applyFilter);
    if(ui.mApply) ui.mApply.addEventListener("click", applyFilter);

    var saved = readSelection();
    if(saved && saved.brand){
      syncPair(ui.dBrand, ui.mBrand, saved.brand);
      updateSeriesOptions(data, saved.brand);
      if(saved.series){
        syncPair(ui.dSeries, ui.mSeries, saved.series);
        updateBodyOptions(data, saved.brand, saved.series);
        if(saved.body) syncPair(ui.dBody, ui.mBody, saved.body);
      }
    }
  }

  /*
    MutationObserver нужен, чтобы повторно применить фильтр после
    "Показать ещё" или внутренних перерисовок ST320N.
  */
  function setupObserver(){
    var parts = getStoreParts();
    if(!parts.grid || !window.MutationObserver) return;
    if(STATE.observer) STATE.observer.disconnect();

    STATE.observer = new MutationObserver(function(){
      if(!STATE.activeFilter) return;
      if(STATE.debounceTimer) window.clearTimeout(STATE.debounceTimer);
      STATE.debounceTimer = window.setTimeout(function(){ applyFilterToDom(STATE.activeFilter); }, 180);
    });
    STATE.observer.observe(parts.grid, { childList: true, subtree: true });
  }

  function init(){
    fetchData()
      .then(function(data){
        bindUi(data);
        setupObserver();
      })
      .catch(function(err){
        alert("Ошибка загрузки данных фильтра: " + err.message + "\nПроверьте: 1) CFG.SHEET.SHEET_PUBHTML_URL/CSV_URL/GID/SHEET_ID, 2) опубликована ли таблица, 3) нет ли блокировок сети/VPN.");
      });
  }

  if(document.readyState === "loading") document.addEventListener("DOMContentLoaded", init);
  else init();
})();
</script>

<!-- ЧЕК-ЛИСТ (если что-то не работает):
1) Селекты пустые: проверьте CFG.SHEET.SHEET_PUBHTML_URL/CSV_URL/GID и имена колонок в CFG.SHEET.COLUMNS.
2) Карточки не находятся: проверьте CFG.STORE.GRID_SELECTOR и CFG.STORE.CARD_SELECTOR по DOM вашего ST320N.
3) UID не извлекается: проверьте CFG.CARD.LINK_SELECTOR и CFG.CARD.UID_REGEX.
4) Нет совпадений при очевидно правильном выборе: проверьте формат "Characteristics:Совместимость" (строго через ";").
5) Видите старые данные: временно включите CFG.CACHE.FORCE_REFRESH = true.
6) Если "failed to fetch": фильтр теперь сначала читает данные из каталога Tilda; если брендов 0 — включите CFG.DBG=true и пришлите логи.
7) Для JSONP-фолбэка можно явно указать CFG.SHEET.SHEET_ID (из URL /d/e/<ID>). -->
